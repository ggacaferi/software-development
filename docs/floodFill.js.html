<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: floodFill.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: floodFill.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) 2025
 * All rights reserved.
 */

/**
 * Prints a visual representation of the Battlesnake board to the console.
 *
 * - Your snake's head is shown as 'H', body as 'S'.
 * - Enemy snakes' heads are 'h', bodies are 'E'.
 * - Food is shown as 'F'.
 * - Empty spaces are '.'.
 *
 * @param {Object} gameState - The current game state, including board, food, and snakes.
 * @param {Object} gameState.board - The board object containing width, height, food, and snakes.
 * @param {number} gameState.board.width - The width of the board.
 * @param {number} gameState.board.height - The height of the board.
 * @param {Array&lt;Object>} gameState.board.food - Array of food positions, each with x and y.
 * @param {Array&lt;Object>} gameState.board.snakes - Array of snake objects on the board.
 * @param {Object} gameState.you - The player's snake object (used to distinguish your snake).
 */

export function floodFill(startPos, boardState, maxIterations = null) {
    const { width, height, map } = boardState;
    const visited = Array(height).fill(null).map(() => Array(width).fill(false));
    const queue = [];
    let area = 0;

    // Dynamically set maxIterations based on map size if not provided
    if (!maxIterations) {
        maxIterations = Math.min(width * height, 1000); // Cap iterations for large maps
    }

    // Check if starting position is out of bounds or blocked
    if (startPos.x &lt; 0 || startPos.x >= width ||
        startPos.y &lt; 0 || startPos.y >= height ||
        map[startPos.y][startPos.x] === 1) {
        return 0;
    }

    queue.push(startPos);
    visited[startPos.y][startPos.x] = true;

    const directions = [
        { x: 0, y: 1 },  // up
        { x: 0, y: -1 }, // down
        { x: -1, y: 0 }, // left
        { x: 1, y: 0 }   // right
    ];

    while (queue.length > 0 &amp;&amp; area &lt; maxIterations) {
        const current = queue.shift();
        area++;

        for (const direction of directions) {
            const newX = current.x + direction.x;
            const newY = current.y + direction.y;

            // Check boundaries
            if (newX >= 0 &amp;&amp; newX &lt; width &amp;&amp; newY >= 0 &amp;&amp; newY &lt; height) {
                // Check if already visited or blocked
                if (visited[newY][newX] || map[newY][newX] === 1) {
                    continue;
                }
                visited[newY][newX] = true;
                queue.push({ x: newX, y: newY });
            }
        }
    }

    return area;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#allowTailCollision">allowTailCollision</a></li><li><a href="global.html#checkEnemyCollisionPossibilities">checkEnemyCollisionPossibilities</a></li><li><a href="global.html#checkPossibleCollision">checkPossibleCollision</a></li><li><a href="global.html#checkSegmentCollision">checkSegmentCollision</a></li><li><a href="global.html#checkTailCollision">checkTailCollision</a></li><li><a href="global.html#chooseBestMoveWithLookahead">chooseBestMoveWithLookahead</a></li><li><a href="global.html#determineTarget">determineTarget</a></li><li><a href="global.html#end">end</a></li><li><a href="global.html#evaluateCollisionRisk">evaluateCollisionRisk</a></li><li><a href="global.html#evaluateGameState">evaluateGameState</a></li><li><a href="global.html#findClosestFood">findClosestFood</a></li><li><a href="global.html#findClosestSmallerSnake">findClosestSmallerSnake</a></li><li><a href="global.html#floodFill">floodFill</a></li><li><a href="global.html#getClosestFoodItem">getClosestFoodItem</a></li><li><a href="global.html#getDirectionToTarget">getDirectionToTarget</a></li><li><a href="global.html#getHorizontalMove">getHorizontalMove</a></li><li><a href="global.html#getManhattanDistance">getManhattanDistance</a></li><li><a href="global.html#getVerticalMove">getVerticalMove</a></li><li><a href="global.html#headToHeadMovement">headToHeadMovement</a></li><li><a href="global.html#info">info</a></li><li><a href="global.html#preventOtherSnakeCollision">preventOtherSnakeCollision</a></li><li><a href="global.html#preventSelfCollision">preventSelfCollision</a></li><li><a href="global.html#preventWallCollision">preventWallCollision</a></li><li><a href="global.html#printBoard">printBoard</a></li><li><a href="global.html#simulateMove">simulateMove</a></li><li><a href="global.html#start">start</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Jun 21 2025 22:56:47 GMT+0300 (Eastern European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
